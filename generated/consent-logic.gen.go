/*
 * This file is part of nuts-consent-logic.
 *
 * nuts-consent-logic is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * nuts-consent-logic is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with nuts-consent-logic.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Package generated provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"strings"
	"time"
)

// ConsentValidationRequest defines component schema for ConsentValidationRequest.
type ConsentValidationRequest struct {
	ConsentId *string `json:"consentId,omitempty"`
}

// CreateConsentRequest defines component schema for CreateConsentRequest.
type CreateConsentRequest struct {
	InvolvedParties *struct {
		Actors    []string `json:"actors,omitempty"`
		Custodian string   `json:"custodian"`
		Subject   *string  `json:"subject,omitempty"`
	} `json:"involvedParties,omitempty"`
	Meta *struct {
		ConsentProof *struct {
			ContentType *string `json:"contentType,omitempty"`
			Data        *string `json:"data,omitempty"`
		} `json:"consentProof,omitempty"`
		PerformerIdentity *struct {
			ContentType *string `json:"contentType,omitempty"`
			Contract    *string `json:"contract,omitempty"`
		} `json:"performerIdentity,omitempty"`
		Period *struct {
			End   *time.Time `json:"end,omitempty"`
			Start *time.Time `json:"start,omitempty"`
		} `json:"period,omitempty"`
	} `json:"meta,omitempty"`
}

// JobCreatedResponse defines component schema for JobCreatedResponse.
type JobCreatedResponse struct {
	JobId      *string `json:"jobId,omitempty"`
	ResultCode *string `json:"resultCode,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a new consent. (POST /api/consent)
	NutsConsentLogicCreateConsent(ctx echo.Context) error
	// Create the validity of a consent-request job (POST /api/consent/validation)
	NutsConsentLogicValidateConsent(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// NutsConsentLogicCreateConsent converts echo context to params.
func (w *ServerInterfaceWrapper) NutsConsentLogicCreateConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NutsConsentLogicCreateConsent(ctx)
	return err
}

// NutsConsentLogicValidateConsent converts echo context to params.
func (w *ServerInterfaceWrapper) NutsConsentLogicValidateConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NutsConsentLogicValidateConsent(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/api/consent", wrapper.NutsConsentLogicCreateConsent)
	router.POST("/api/consent/validation", wrapper.NutsConsentLogicValidateConsent)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"08Onh38HAAD//wSnOVbEEwAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

