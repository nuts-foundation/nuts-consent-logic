/*
 * This file is part of nuts-consent-logic.
 *
 * nuts-consent-logic is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * nuts-consent-logic is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with nuts-consent-logic.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Package generated provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"strings"
	"time"
)

// ActorURI defines component schema for ActorURI.
type ActorURI string

// ConsentValidationRequest defines component schema for ConsentValidationRequest.
type ConsentValidationRequest struct {
	ConsentId *string `json:"consentId,omitempty"`
}

// CreateConsentRequest defines component schema for CreateConsentRequest.
type CreateConsentRequest struct {
	Actors       []ActorURI `json:"actors"`
	ConsentProof struct {
		// Embedded struct due to allOf(#/components/schemas/EmbeddedData)
		EmbeddedData
	} `json:"consentProof,omitempty"`
	Custodian CustodianURI   `json:"custodian"`
	Performer *IdentifierURI `json:"performer,omitempty"`
	Period    *Period        `json:"period,omitempty"`
	Subject   SubjectURI     `json:"subject"`
}

// CustodianURI defines component schema for CustodianURI.
type CustodianURI string

// EmbeddedData defines component schema for EmbeddedData.
type EmbeddedData struct {
	ContentType string `json:"contentType"`
	Data        string `json:"data"`
}

// IdentifierURI defines component schema for IdentifierURI.
type IdentifierURI string

// JobCreatedResponse defines component schema for JobCreatedResponse.
type JobCreatedResponse struct {
	JobId      *string `json:"jobId,omitempty"`
	ResultCode *string `json:"resultCode,omitempty"`
}

// Period defines component schema for Period.
type Period struct {
	End   time.Time `json:"end"`
	Start time.Time `json:"start"`
}

// SubjectURI defines component schema for SubjectURI.
type SubjectURI string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a new consent. (POST /api/consent)
	NutsConsentLogicCreateConsent(ctx echo.Context) error
	// Create the validity of a consent-request job (POST /api/consent/validation)
	NutsConsentLogicValidateConsent(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// NutsConsentLogicCreateConsent converts echo context to params.
func (w *ServerInterfaceWrapper) NutsConsentLogicCreateConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NutsConsentLogicCreateConsent(ctx)
	return err
}

// NutsConsentLogicValidateConsent converts echo context to params.
func (w *ServerInterfaceWrapper) NutsConsentLogicValidateConsent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NutsConsentLogicValidateConsent(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/api/consent", wrapper.NutsConsentLogicCreateConsent)
	router.POST("/api/consent/validation", wrapper.NutsConsentLogicValidateConsent)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

